DECLARATIVA E IMPERACTICA.




Codigo para realizar un sort a una lista con una condicion lambda.

List<String> lista = new ArrayList<>();
	lista.add("Juan");
	lista.add("Diego");
	lista.add("Sebastian");
    	
	for(String elemento: lista){
	System.out.println(elemento);
	}
	
	
	
Codigo para realizar impresion de una lista con un metodo funcional de java 8

	//En expresion lambda
	lista.forEach(x -> System.out.println(x));

	//En expresion funcional
	lista.forEach(System.out::println);

Este es para ordenar con un sort
	//lambda
	Collections.sort(lista, (String p1, String p2) -> p1.compareTo(p2));      
	//Funcional
	lista.sort((x,y) -> x.compareTo(y));
	
	o tambien se pude realizar 
	
	Arrays.sort(nombres, String::compareToIgnoreCase);

y este es para remover cumpliendo alguna condicion

	lista.removeIf(x -> x.equalsIgnoreCase("Juan"));
	
	
Estos son metodos funcionales de java 8 para simplicar el codigo, tambien los podemos usar con expresiones
lambda como lo hice en el prrimer ejemplo.


De esta forma podemos referencia una clase A que contien la clase B y solo llamar el metodo y enviar los parametros.
(Ejemplo MetodosReferenciadosApp)

iPersona iper3 = Persona::new;
Persona per = iper3.crear(1, "Sebastian");





STREAM

Como podemos filtrar o poner una condicion en una lista usando stream y filter e imprimirlo con la funcion 
foreach llamandolo como metodo de referencia

lista.stream().filter(x -> x.startsWith("J")).forEach(System.out::println);

Ordenar en Forma Ascendente
	lista.stream().sorted().forEach(System.out::println);
		
Ordenar en Forma Descendente
	lista.stream().sorted((x,y) -> y.compareTo(x)).forEach(System.out::println);

	
transformar o convertir, en este caso el ejemplo convierte toda la lista a mayusculas.
		lista.stream().map(String::toUpperCase).forEach(System.out::println);
	
hacer suma de toda una lista

	lista.stream().reduce(Integer::sum);
	
		
		
STREAM PARALELO

	numeros.parallelStream().forEach(System.out::println);
	
	double total=lista.stream().parallel().filter(elemento->(elemento>200)).mapToDouble(elemento->elemento*1.21).sum();
	
	

USO DE MAP

LLENADO

	private Map<Integer, String> map;
	
	public void llenar(){
		map = new HashMap<>();
		map.put(1, "Juan Diego");
		map.put(2, "Sebastian");
		map.put(3, "Jose Ignacio");
		map.put(4, "Adrian Maria");
	}

IMPRIMIR VALORES

	map.entrySet().stream().forEach(System.out::println);

PONER SI NO EXISTE

	map.putIfAbsent(5, "Karine");
	
HACER SI EXISTE
	map.computeIfPresent(3, (k,v)-> k + v);
	
OBTENER VALOR Y SI NO EXISTE PONER POR DEFAULT
	String valor = map.getOrDefault(6, "Valor por defecto");
	
RECOLECTAR CON CONDICION DE UN MAPA A OTRO

	public void recolectar(){
		Map<Integer, String> mapaRecolectado = map.entrySet().stream()
				.filter(e->e.getValue().contains("J"))
				.collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));
				
		mapaRecolectado.forEach((k,v) -> System.out.println("LLave " + k + " Valor " + v));
	}
	
	
	
	
DATE API

Tomar los milisegundo y compararlos, tambien se puede hacer en segundo y horas.
		Instant ini = Instant.now();
		Thread.sleep(1000);			
		Instant fin = Instant.now();
		System.out.println(Duration.between(ini, fin));
		System.out.println(Duration.between(ini, fin).toMillis());
		
COMPARAR DOS FECHAS Y TOMAR SUS PERIODOS

	LocalDate nacimiento = LocalDate.of(1996, 3, 4);
	LocalDate actual = LocalDate.now();
	
	Period periodo = Period.between(nacimiento, actual);
	System.out.println("Han pasado " + periodo.getYears() + " años, "
			+ "" + periodo.getMonths() + " meses y " + periodo.getDays()+" días.");
						
						
CONVERTIR O DARLE FORMATO A UNA FECHA

			String fecha = "04/03/1996";
			DateTimeFormatter formateador = DateTimeFormatter.ofPattern("dd/MM/yyyy");
			LocalDate fechaLocal = LocalDate.parse(fecha, formateador);
			System.out.println(fechaLocal);
			System.out.println(formateador.format(fechaLocal));			
			formateador = DateTimeFormatter.ofPattern("ddMMyyyy");
			System.out.println(formateador.format(fechaLocal));
			
			


FUNCION DE ALTO ORDEN:

DONDE PODEMOS EN UN METODO LLAMAR VARIAS FUNCIONES COMO UN CONSUMER Y DENTRO DE LA MISMA
LLAMAR UN PREDICATE QUE NOS DEFINA UN PROCESO LOGICO.

ESTO SE PUEDE VER EN AltoOrdenApp

public void filtrar(List<String> lista, Consumer<String> consumidor, int longitud, String cadena){
		lista.stream().filter(this.establecerLogica(cadena)).forEach(consumidor);
	}
	
	
		public Predicate<String> establecerLogica(int longitud){
		return texto -> texto.length() < longitud;
	}
	
	public Predicate<String> establecerLogica(String cadena){
		return texto -> texto.contains(cadena);
	}
	
	List<String> lista = new ArrayList<String>();
		lista.add("Juan");
		lista.add("Sebastian");
		lista.add("Jose");
		lista.add("Adriana");
		//app.filtrar(lista, System.out::println, 5, null);
		app.filtrar(lista, System.out::println, 0, "J");
		
		
		
Y TAMBIEN SE PUEDE USAR PARA RECIBIR UNA FUNCION Y SACAR UNA RESPUESTA.


	private Function<String, String> convertirMayusculas = x -> x.toUpperCase();
	private Function<String, String> convertirMinusculas = x -> x.toLowerCase();
	
	public void imprimir(Function<String, String> funcion, String valor){		
		System.out.println(funcion.apply(valor));
	}
	
	
	app.imprimir(app.convertirMayusculas, "cadena en minuscula");
	app.imprimir(app.convertirMinusculas, "CADENA EN MAYUSCULAS");
		
		
	public Function<String, String> mostrar(String mensaje){	
		return (String x) -> mensaje + x;
	}
	
		
	String respuesta = app.mostrar("Hola ").apply("Mensaje Salida");
	System.out.println(respuesta);
			
			
			
			
			
OPTIONAL 

		Optional.ofNullable(cadena1);
		
		Optional<Integer>  c = Optional.empty();
		c.ofNullable(cadena1);		
		
		Optional<Integer>  b = Optional.ofNullable(valor2);		
		
		System.out.println(a.isPresent());
				
		Integer valor2 = b.orElse(0);
		
		
		Optional<OBJETO> perona = Optional.ofNullable(valoX);
		return persona.orElse(new persona(x,x,x,x,x));
		
		
			
		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			